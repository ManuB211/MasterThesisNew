package at.ac.c3pro.changePropagation;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jbpt.algo.tree.rpst.IRPSTNode;
import org.jbpt.algo.tree.tctree.TCType;

import at.ac.c3pro.ImpactAnalysis.ImpactAnalysisUtil.Pair;
import at.ac.c3pro.change.Delete;
import at.ac.c3pro.change.IChangeOperation;
import at.ac.c3pro.change.Insert;
import at.ac.c3pro.change.Replace;
import at.ac.c3pro.chormodel.Choreography;
import at.ac.c3pro.chormodel.ChoreographyModel;
import at.ac.c3pro.chormodel.IPublicModel;
import at.ac.c3pro.chormodel.IRole;
import at.ac.c3pro.chormodel.IRpstModel;
import at.ac.c3pro.chormodel.PublicModel;
import at.ac.c3pro.chormodel.Role;
import at.ac.c3pro.chormodel.RpstModel;
import at.ac.c3pro.node.Edge;
import at.ac.c3pro.node.Event;
import at.ac.c3pro.node.IChoreographyNode;
import at.ac.c3pro.node.IGateway;
import at.ac.c3pro.node.INode;
import at.ac.c3pro.util.FragmentUtil;

public class ChangePropagationUtil {

	// TODO add choreography reference to statistics

	public static int nbOp = 0;

	public static enum ChgOpType {
		Insert, Replace, Delete, Update
	};
	// public static Map<String,Stats> ChgOpId2Stats = new HashMap<String, Stats>();
	// The two following maps are used to gather metrics to be compared with the
	// ImpactAnalysis (prediction graph)
	// Given a set of changes propagation, Centrality measures the number of times a
	// partner is affected
	// Propagation graph measures the propagation dependency graph
	// UNCOMMENT
	// public static Map<IRole,Integer> centrality = new HashMap<IRole,Integer>();
	// public static Map<Pair<IRole,IRole>, Integer> PropagationGraphMetrics = new
	// HashMap<Pair<IRole,IRole>, Integer>();

	// TODO Correct the exception generated by the Graph reduction -- and change the
	// graphreduction attribute in the following to true

	// init the centrality and propagation graph metrics
	public static void init(Choreography c) {
		// UNCOMMENT

		/*
		 * for(IRole r : c.collaboration.roles) centrality.put(r, 0); for(IRole r1 :
		 * c.collaboration.roles) for(IRole r2 : c.collaboration.roles){ if(r1!=r2)
		 * PropagationGraphMetrics.put(new Pair<IRole,IRole>(r1,r2) ,0); }
		 * System.out.println("---centrality");
		 * System.out.println(ChangePropagationUtil.centrality);
		 * System.out.println("---Propagation graph");
		 * System.out.println(ChangePropagationUtil.PropagationGraphMetrics);
		 */

	}

	// Propagate a change operation:
	// Chg_Root_id = null if it is the initial request, otherwise if it a result of
	// propagation then we put the id of the chge request that called it
	// stats = null in case of initial request. If it is an inferred change then,
	// stats = stats of the root operation

	public static <E extends Edge<N>, N extends INode> Map<Role, List<IChangeOperation>> propagate(IChangeOperation op,
			String Chg_Root_id, Stats stats, Map<String, Stats> chgOpId2Stats, Map<IRole, Integer> centrality,
			Map<Pair<IRole, IRole>, Integer> PropagationGraphMetrics) {

		switch (op.getType()) {
		case Replace:
			return replacePropagate((Replace<E, N>) op, Chg_Root_id, stats, chgOpId2Stats, centrality,
					PropagationGraphMetrics);
		case Insert:
			return insertPropagate((Insert<E, N>) op, Chg_Root_id, stats, chgOpId2Stats, centrality,
					PropagationGraphMetrics);
		case Delete: {
			if (((Delete) op).activity != null)
				return deleteNodePropagate((Delete<E, N>) op, Chg_Root_id, stats, chgOpId2Stats, centrality,
						PropagationGraphMetrics);
			else
				return deletePropagate((Delete<E, N>) op, Chg_Root_id, stats, chgOpId2Stats, centrality,
						PropagationGraphMetrics);
		}
		default:
			System.out.println("invalid change operation");
			break;
		}
		return null;
	}

	// TODO: add public -> choreography mapping: Map <IPublicNode,
	// IChoreographyNode>
	// TODO: add choreography -> public mapping: Map <IChoreographyNode,
	// Pair<IPublicNode, IPublicNode>>
	public static <E extends Edge<N>, N extends INode> Map<Role, List<IChangeOperation>> replacePropagate(
			Replace<E, N> replace, String Chg_Root_id, Stats stats, Map<String, Stats> chgOpId2Stats,
			Map<IRole, Integer> centrality, Map<Pair<IRole, IRole>, Integer> PropagationGraphMetrics) {

		Map<Role, List<IChangeOperation>> changeOps = new HashMap<Role, List<IChangeOperation>>();
		ChoreographyModel G = (ChoreographyModel) replace.c.choreo;
		Set<Role> businessPartners = FragmentUtil.extractRoles(replace.f1);
		// System.out.println("f1 affected partners"+businessPartners);
		businessPartners.addAll(FragmentUtil.extractRoles(replace.f2.getRoot()));
		businessPartners.remove(replace.currentRole);

		if (stats == null) {
			// UNCOMMENT
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Propagation of Fragment Replacement in
			// "+replace.currentRole+ " of Fragment "+replace.f1.getFragment()+ " by "
			// +replace.f2.getdigraph());
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Affected business partners: " + businessPartners);
			stats = new Stats(replace.currentRole, ChgOpType.Replace, replace.f2.getRoot(), replace.f1);
		}
		if (Chg_Root_id == null)
			Chg_Root_id = replace.getId();

		// calculate F_G = alpha_G(F); Edges and nodes are of a different type
		// TODO: we might have an explicit mapping Map<IPublicNode, IChoreographyNode>,
		// which we could use here
		// IRPSTNode<Edge<IChoreographyNode>, IChoreographyNode> f_G =
		// FragmentUtil.getCorrespondingGlobalFragment(replace.f1, G);
		// System.out.println("Change Requester Partner :"+ replace.currentRole);
		// System.out.println("f_1: " + replace.f1.getFragment());
		// System.out.println("F_2: " + replace.f2.getdigraph());
		// System.out.println("F_G: " + f_G.getFragment());

		// get all roles in F_G

		// System.out.println("f2 affected
		// partners"+FragmentUtil.extractRoles(replace.f2.getRoot()));
		// we only want the business partners, remove currentRole from the set

		for (Role p : businessPartners) {
			List<IChangeOperation> changeOps_partner = new LinkedList<IChangeOperation>();
			// UNCOMMENT
			// if(Chg_Root_id == replace.getId())
			// System.out.println("-- business partner: " + p.name);

			IRpstModel<E, N> publicModel_p = (IRpstModel<E, N>) replace.c.collaboration.R2PuM.get(p);
			String graphname = "changePropReplace_rf1_" + p.name;
			// System.out.println("...writing graph to " + graphname + "Model.dot");
			// System.out.println("...writing rpst to " + graphname + "Rpst.dot");
			// IOUtils.toFile(graphname+"Model.dot", publicModel_p.getdigraph().toDOT());
			// IOUtils.toFile(graphname+"Rpst.dot", ((PublicModel) publicModel_p).toDOT());

			// IRPSTNode<E,N> rf1 = FragmentUtil.getCorrespondingLocalFragment(f_G,
			// (RpstModel<E,N>) publicModel_p);
			// System.out.println("rf1 = "+rf1);
			// System.out.println("bounded fragment for partner: " +
			// publicModel_p.getFragmentBoundedBy(rf1.getEntry(), rf1.getExit()));

			// which branch: insert, delete or replace?
			// System.out.println("f1: " + replace.f1);
			// System.out.println("f2: " + replace.f2.getdigraph());
			// System.out.println("FragmentUtil.projectRole(f1, " + p + "): ");
			IRpstModel<E, N> f1_p_model = FragmentUtil.projectRole(replace.f1, p, replace.model.getdigraph(), true);
			IRPSTNode<E, N> f1_p = null;
			if (null != f1_p_model) {
				f1_p = f1_p_model.getRoot();
			}
			// System.out.println("FragmentUtil.projectRole(f2, " +replace.f2.getdigraph()+
			// " on "+p + "): ");
			IRpstModel<E, N> f2_p_model = FragmentUtil.projectRole(replace.f2.getRoot(), p, replace.f2.getdigraph(),
					true);
			IRPSTNode<E, N> f2_p = null;
			if (null != f2_p_model) {
				f2_p = f2_p_model.getRoot();
			}
			// System.out.println("f1_p: " + f1_p);
			// System.out.println("f2_p: " + f2_p);

			// System.out.println("... writing fragment graph to " + graphname +
			// "FragmentModel.dot");
			// IOUtils.toFile(graphname+"FragmentModel.dot",
			// f1_p.getFragment().getGraph().toDOT());

			if (!FragmentUtil.fragmentIsEqual(f1_p, f2_p)) {
				// System.out.println("#### AFTER fragmentIsEqual");
				// UNCOMMENT
				if (Chg_Root_id == replace.getId()) {
					int newvalue = centrality.get(p) + 1; // used for metrics
					centrality.put(p, newvalue);
					for (Pair<IRole, IRole> pair : PropagationGraphMetrics.keySet()) {
						if (pair.first.equals(replace.currentRole) && pair.second.equals(p))
							PropagationGraphMetrics.put(pair, PropagationGraphMetrics.get(pair) + 1);
					}
				}
				/*
				 * if (f1_p == null) { System.out.println("-- REPLACE/INSERT BRANCH"); // 3)
				 * insert branch N in = replace.f1.getEntry();
				 * //replace.model.getRealEntry(replace.f1); N out = replace.f1.getExit();
				 * //replace.model.getRealExit(replace.f1); IRpstModel<E,N> f3_p_model =
				 * FragmentUtil.projectRole(replace.f2.getRoot(), p, replace.f2.getdigraph(),
				 * true); changeOps_partner.addAll(insertPropagate(new
				 * Insert<E,N>((RpstModel)f3_p_model, replace.model, in, out, replace.c,
				 * replace.currentRole), replace.getId(), stats, chgOpId2Stats,centrality,
				 * PropagationGraphMetrics).get(p)); } else { if (f2_p == null) {
				 * System.out.println("-- REPLACE/DELETE BRANCH");
				 * if(FragmentUtil.collectActivities(f1_p).size() == 1 &&
				 * FragmentUtil.collectGateways(f1_p).size() == 0){ // graph = Start -> activity
				 * --> End (deletion of single activity for(N activity :
				 * FragmentUtil.collectActivities(f1_p)){
				 * changeOps_partner.addAll(deleteNodePropagate(new Delete<E,N>(activity,
				 * replace.model, replace.c, replace.currentRole), replace.getId(), stats,
				 * chgOpId2Stats,centrality, PropagationGraphMetrics).get(p)); } } else
				 * //deletion of a fragment changeOps_partner.addAll(deletePropagate(new
				 * Delete<E,N>(f1_p, replace.model, replace.c, replace.currentRole),
				 * replace.getId(), stats, chgOpId2Stats,centrality,
				 * PropagationGraphMetrics).get(p)); } else {
				 * System.out.println("-- REPLACE/REPLACE BRANCH"); // 5) replace branch //
				 * adding the instantiated replace change operation // rf1 = the "old" fragment
				 * in the original partner's public model //System.out.println("rf1: " + rf1);
				 * //System.out.println("f1_p: " + f1_p);
				 * 
				 * // TODO: add delete operations for deleted activities
				 * 
				 * // IFragment<E,N> alone is empty, but the graph is not. // If we build a new
				 * RpstModel<E,N> from that one we // can extract the IRPSTNode<E,N>
				 * 
				 * IFragment<E,N> rf2 = FragmentUtil.complement(f2_p, p); RpstModel<E,N>
				 * rf2_model = new RpstModel<E,N>((MultiDirectedGraph<E,N>) rf2.getGraph(),
				 * "fragment"); //System.out.println("rf2: " + rf2_model.getRoot());
				 * //f1_p_model Set<N> list_activities = new HashSet<N>(); List<IRPSTNode<E,N>>
				 * list_rpstn = new LinkedList<IRPSTNode<E,N>>(); for(N activity :
				 * FragmentUtil.collectActivities(f1_p)){ //System.out.println("--- activitiy: "
				 * + activity); N casted = (N) replace.c.collaboration.Pu2Pu.get(activity);
				 * //System.out.println("Pu2Pu lookup: " +
				 * replace.c.collaboration.Pu2Pu.get(activity));
				 * //System.out.println("--- casted: " + casted); list_activities.add(casted);
				 * //System.out.println("getFragmentWithSourceOrTarget: " + ((RpstModel<E,N>)
				 * publicModel_p).getFragmentWithSourceOrTarget(activity));
				 * list_rpstn.add(((RpstModel<E,N>)
				 * publicModel_p).getFragmentWithSourceOrTarget(activity)); }
				 * 
				 * IRPSTNode<E,N> fragmentTarget = ((RpstModel<E,N>)
				 * publicModel_p).getsmallestFragment(list_rpstn);
				 * 
				 * Replace replaceForPartner = new Replace<E,N>(fragmentTarget,
				 * rf2_model.getRoot()); changeOps_partner.add(replaceForPartner); //TODO the
				 * second argument of the Replace should be replaced by a a merge of
				 * fragmentTarget and rf2_model.getRoot() //System.out.println("list_rpstn: " +
				 * list_rpstn); //System.out.println("fragmentTarget: " + fragmentTarget);
				 * //System.out.println("rf2_model.getRoot(): " + rf2_model.getRoot());
				 * stats.updatePropagationStats(fragmentTarget, rf2_model.getRoot(), Chg_Root_id
				 * == replaceForPartner.getId()); //int size =
				 * FragmentUtil.collectXORGateways(fragmentTarget).size() +
				 * FragmentUtil.collectXORGateways(rf2_model.getRoot()).size();
				 * //System.out.println("Target Fragment Count: " + size);
				 * 
				 * //IOUtils.toFile("debug/"+graphname+"FragmentModel_target.dot",
				 * FragmentUtil.generateCloneModelFromFragment( //fragmentTarget,
				 * (RpstModel<E,N>) publicModel_p).getGraph().toDOT());
				 * //IOUtils.toFile("debug/"+graphname+"FragmentModel_target2.dot",
				 * rf2_model.getGraph().toDOT());
				 * //IOUtils.toFile("debug/"+graphname+"FragmentModel_target2_reduced.dot",
				 * rf2_model.reduceGraph().getGraph().toDOT()); } }
				 */
			} else {
				// System.out.println("----- EQUAL CASE");
				// System.out.println("replace.getId(): " + replace.getId());
			}
			// UNCOMMENT
			// System.out.println("changeOps_partner= "+changeOps_partner);
			changeOps.put(p, changeOps_partner);
		}

		// System.out.println("change operations:" + changeOps);
		if (Chg_Root_id == replace.getId())
			chgOpId2Stats.put(Chg_Root_id, stats);
		return changeOps;
	}

	/**
	 * Delete propagation implementation
	 */

	public static <E extends Edge<N>, N extends INode> Map<Role, List<IChangeOperation>> deletePropagate(
			Delete<E, N> delete, String Chg_Root_id, Stats stats, Map<String, Stats> chgOpId2Stats,
			Map<IRole, Integer> centrality, Map<Pair<IRole, IRole>, Integer> PropagationGraphMetrics) {

		Map<Role, List<IChangeOperation>> changeOps = new HashMap<Role, List<IChangeOperation>>();
		Set<Role> businessPartners = FragmentUtil.extractRoles(delete.f1);
		businessPartners.remove(delete.currentRole);

		if (stats == null) {
			// UNCOMMENT
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Propagation of Fragment Deletion in "+delete.currentRole+
			// " of Fragment "+delete.f1.getFragment());
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Affected business partners: " + businessPartners +" "+
			// businessPartners.size());
			stats = new Stats(delete.currentRole, ChgOpType.Delete, delete.f1);
		}
		if (Chg_Root_id == null)
			Chg_Root_id = delete.getId();

		for (Role p : businessPartners) {
			// UNCOMMENT
			// if(Chg_Root_id == delete.getId())
			// System.out.println("-- business partner: " + p.name);
			List<IChangeOperation> changeOps_partner = new LinkedList<IChangeOperation>();
			// UNCOMMENT
			if (Chg_Root_id == delete.getId()) {
				int newvalue = centrality.get(p) + 1; // used for metrics
				centrality.put(p, newvalue);
				for (Pair<IRole, IRole> pair : PropagationGraphMetrics.keySet()) {
					if (pair.first.equals(delete.currentRole) && pair.second.equals(p))
						PropagationGraphMetrics.put(pair, PropagationGraphMetrics.get(pair) + 1);
				}
			}

			/*
			 * IRpstModel<E,N> publicModel_p = (IRpstModel<E,N>)
			 * delete.c.collaboration.R2PuM.get(p); String graphname =
			 * "changePropDelete_rf1_" + p.name; //IOUtils.toFile(graphname+"Model.dot",
			 * publicModel_p.getdigraph().toDOT()); //IOUtils.toFile(graphname+"Rpst.dot",
			 * ((PublicModel) publicModel_p).toDOT()); IRPSTNode<E, N> f1_p =
			 * FragmentUtil.projectRole(delete.f1, p, delete.model.getdigraph(),
			 * true).getRoot(); //System.out.println("... writing fragment graph to " +
			 * graphname + "FragmentModel.dot");
			 * //IOUtils.toFile(graphname+"FragmentModel.dot",
			 * f1_p.getFragment().getGraph().toDOT()); IRpstModel<E,N> pumPostdeletePropag =
			 * publicModel_p; for (N activity : FragmentUtil.collectActivities(f1_p)) { N
			 * matching_Node = (N) delete.c.collaboration.Pu2Pu.get(activity);
			 * changeOps_partner.add(new Delete<E,N>(matching_Node, publicModel_p,
			 * delete.c,p)); pumPostdeletePropag =
			 * pumPostdeletePropag.delete(matching_Node); }
			 * //IOUtils.toFile(graphname+"_PumPostdeletePropag.dot",
			 * pumPostdeletePropag.getdigraph().toDOT()); //UNCOMMENT
			 * //System.out.println("changeOps_partner= "+changeOps_partner);
			 * changeOps.put(p, changeOps_partner); if(Chg_Root_id == delete.getId())
			 * stats.updatePropagationStats(ChgOpType.Delete, publicModel_p,
			 * pumPostdeletePropag, true); else{
			 * stats.updatePropagationStats(ChgOpType.Delete, publicModel_p,
			 * pumPostdeletePropag, false); }
			 */
		}

		// System.out.println("change operations to be propagated:" + changeOps);
		if (Chg_Root_id == delete.getId()) {
			chgOpId2Stats.put(Chg_Root_id, stats);
		}

		return changeOps;
	}

	public static <E extends Edge<N>, N extends INode> Map<Role, List<IChangeOperation>> deleteNodePropagate(
			Delete<E, N> delete, String Chg_Root_id, Stats stats, Map<String, Stats> chgOpId2Stats,
			Map<IRole, Integer> centrality, Map<Pair<IRole, IRole>, Integer> PropagationGraphMetrics) {

		Map<Role, List<IChangeOperation>> changeOps = new HashMap<Role, List<IChangeOperation>>();
		Set<Role> businessPartners = new HashSet<Role>();
		businessPartners.addAll(delete.activity.getRoles());

		if (stats == null) {
			// UNCOMMENT
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Propagation of Node Deletion in "+delete.currentRole+ "
			// of Node "+delete.activity);
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Affected business partners: " + businessPartners +" "+
			// businessPartners.size());
			stats = new Stats(delete.currentRole, ChgOpType.Delete, 1, 1, 0, 0); // nb_act = nb_nodes = 1
		}
		if (Chg_Root_id == null)
			Chg_Root_id = delete.getId();

		for (Role p : businessPartners) {
			// UNCOMMENT
			// if(Chg_Root_id == delete.getId())
			// System.out.println("-- business partner: " + p.name);
			List<IChangeOperation> changeOps_partner = new LinkedList<IChangeOperation>();
			// UNCOMMENT
			if (Chg_Root_id == delete.getId()) {
				int newvalue = centrality.get(p) + 1; // used for metrics
				centrality.put(p, newvalue);
				for (Pair<IRole, IRole> pair : PropagationGraphMetrics.keySet()) {
					if (pair.first.equals(delete.currentRole) && pair.second.equals(p))
						PropagationGraphMetrics.put(pair, PropagationGraphMetrics.get(pair) + 1);
				}
			}

			/*
			 * IRpstModel<E,N> publicModel_p = (IRpstModel<E,N>)
			 * delete.c.collaboration.R2PuM.get(p); String graphname =
			 * "changePropDelete_rf1_" + p.name; //IOUtils.toFile(graphname+"Model.dot",
			 * publicModel_p.getdigraph().toDOT()); //IOUtils.toFile(graphname+"Rpst.dot",
			 * ((PublicModel) publicModel_p).toDOT()); //IRPSTNode<E, N> f1_p =
			 * FragmentUtil.projectRole(delete.f1, p, delete.model.getdigraph(),
			 * true).getRoot(); //System.out.println("... writing fragment graph to " +
			 * graphname + "FragmentModel.dot");
			 * //IOUtils.toFile(graphname+"FragmentModel.dot",
			 * f1_p.getFragment().getGraph().toDOT()); IRpstModel<E,N> pumPostdeletePropag =
			 * publicModel_p;
			 * 
			 * N matching_Node = (N) delete.c.collaboration.Pu2Pu.get(delete.activity);
			 * changeOps_partner.add(new Delete<E,N>(matching_Node, publicModel_p,
			 * delete.c,p)); pumPostdeletePropag =
			 * pumPostdeletePropag.delete(matching_Node);
			 * 
			 * 
			 * //IOUtils.toFile(graphname+"_PumPostdeletePropag.dot",
			 * pumPostdeletePropag.getdigraph().toDOT()); //UNCOMMENT
			 * //System.out.println("changeOps_partner= "+changeOps_partner);
			 * changeOps.put(p, changeOps_partner); if(Chg_Root_id == delete.getId())
			 * stats.updatePropagationStats(ChgOpType.Delete, publicModel_p,
			 * pumPostdeletePropag, true); //TODO metrics -- add reduction operations else
			 * stats.updatePropagationStats(ChgOpType.Delete, publicModel_p,
			 * pumPostdeletePropag, false);
			 */
		}

		// System.out.println("change operationsto be propagated:" + changeOps);
		if (Chg_Root_id == delete.getId())
			chgOpId2Stats.put(Chg_Root_id, stats);
		return changeOps;

	}

	/**
	 * This function returns the set of change operations on models target as a
	 * result of an insert on a model source
	 */

	public static <E extends Edge<N>, N extends INode> Map<Role, List<IChangeOperation>> insertPropagate(
			Insert<E, N> insert, String Chg_Root_id, Stats stats, Map<String, Stats> chgOpId2Stats,
			Map<IRole, Integer> centrality, Map<Pair<IRole, IRole>, Integer> PropagationGraphMetrics) {

		Map<Role, List<IChangeOperation>> changeOps = new HashMap<Role, List<IChangeOperation>>();
		ChoreographyModel G = (ChoreographyModel) insert.c.choreo;
		Set<Role> businessPartners = FragmentUtil.extractRoles((IRPSTNode<E, N>) insert.f.getRoot());
		businessPartners.remove(insert.currentRole);

		if (stats == null) {
			// UNCOMMENT
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("Propagation of Fragment Insertion in
			// "+insert.currentRole+ " between nodes "+insert.in+" and "+insert.out);
			// System.out.println("-----------------------------------------------------------------------");
			// System.out.println("-- Affected business partners: " + businessPartners);
			stats = new Stats(insert.currentRole, ChgOpType.Insert, insert.f.getRoot());
		}
		if (Chg_Root_id == null)
			Chg_Root_id = insert.getId();

		// is it possible that businessPartners contain 'null' ? would it be an
		// exception? --> not possible since f2 is not null
		// This is possible only if F do not contain interactions, but here the changes
		// are done on the public model.
		// calculate the position in the choreography model.
		IChoreographyNode chorIn;
		IChoreographyNode chorOut;
		if (insert.in instanceof IGateway) {
			chorIn = insert.c.collaboration.PuGtw2chorGtw.get(insert.in);
		} else if (insert.in instanceof Event) {
			chorIn = G.getStartEvent();
		} else {
			chorIn = insert.c.Pu2Ch.get(insert.in);
		}

		if (insert.out instanceof IGateway) {
			chorOut = insert.c.collaboration.PuGtw2chorGtw.get(insert.out);
		} else if (insert.out instanceof Event) {
			chorOut = G.getEndEvent();
		} else {
			chorOut = insert.c.Pu2Ch.get(insert.out);
		}

		for (Role p : businessPartners) {
			List<IChangeOperation> changeOps_partner = new LinkedList<IChangeOperation>();
			// UNCOMMENT
			// if(Chg_Root_id == insert.getId())
			// System.out.println("- Propagation to business partner: " + p.name);

			// UNCOMMENT
			if (Chg_Root_id == insert.getId()) {
				int newvalue = centrality.get(p) + 1; // used for metrics
				centrality.put(p, newvalue);
				for (Pair<IRole, IRole> pair : PropagationGraphMetrics.keySet()) {
					if (pair.first.equals(insert.currentRole) && pair.second.equals(p))
						PropagationGraphMetrics.put(pair, PropagationGraphMetrics.get(pair) + 1);
				}
			}
			// TODO: handle lookup failure case
			/*
			 * @SuppressWarnings("unchecked") IRpstModel<E,N> publicModel_p =
			 * (IRpstModel<E,N>) insert.c.collaboration.R2PuM.get(p);
			 * 
			 * //System.out.println("publicModel_p: " + publicModel_p); String graphname =
			 * "changePropInsert_rf_" + p.name; //System.out.println("...writing graph to "
			 * + graphname + "Model.dot"); //System.out.println("...writing rpst to " +
			 * graphname + "Rpst.dot"); //IOUtils.toFile(graphname+"Model.dot",
			 * publicModel_p.getdigraph().toDOT()); //IOUtils.toFile(graphname+"Rpst.dot",
			 * ((PublicModel) publicModel_p).toDOT());
			 * 
			 * //System.out.println("FragmentUtil.projectRole(f, " +insert.f.getdigraph() +
			 * "on  " + p + "): "); IRPSTNode<E, N> f_p =
			 * FragmentUtil.projectRole((IRPSTNode<E, N>) insert.f.getRoot(), p,
			 * insert.f.getdigraph(), true).getRoot(); //System.out.println("f_p: " + f_p);
			 * //System.out.println("... writing fragment graph to " + graphname +
			 * "FragmentModel.dot"); //IOUtils.toFile(graphname+"FragmentModel.dot",
			 * f_p.getFragment().getGraph().toDOT());
			 * //System.out.println("... Computing Insertion Position"); Set<N> posIn = new
			 * HashSet<N>(); Set<N> posOut= new HashSet<N>(); if (chorIn == null || chorOut
			 * == null) {
			 * System.out.println("No matching elements in the choreograhyModel for "+insert
			 * .in + "  or "+ insert.out); } else{ //UNCOMMENT //System.out.println("in: " +
			 * chorIn); //System.out.println("out: " + chorOut);
			 * //System.out.println("publicModel_P: " + publicModel_p);
			 * 
			 * //calculating posIn and posOut Pair<N,N> npair; Set<IChoreographyNode>
			 * chorInPartner =
			 * insert.c.choreo.getInclusiveTransitivePreSetWithGateways(chorIn, p);
			 * Set<IChoreographyNode> chorOutPartner =
			 * insert.c.choreo.getInclusiveTransitivePostSetWithGateways(chorOut, p);
			 * //UNCOMMENT //System.out.println("chorinPartner: " + chorInPartner);
			 * //System.out.println("choroutPartner: " + chorOutPartner);
			 * 
			 * for(IChoreographyNode in : chorInPartner){ if(in instanceof Interaction){
			 * npair = (Pair<N, N>) insert.c.Ch2PuPair.get(in);
			 * if(npair.first.equals(insert.in)) posIn.add(npair.second); else
			 * posIn.add(npair.first); } else if(in instanceof Gateway){ for(Pair<IRole,
			 * IGateway> pair : insert.c.ChGtw2PuGtws.get(in)){
			 * if((pair.first.toString().equalsIgnoreCase(p.name))){ posIn.add((N)
			 * pair.second); break; } }
			 * 
			 * } else { posIn.add((N) ((PublicModel) publicModel_p).getStartEvent());
			 * 
			 * } } for(IChoreographyNode out : chorOutPartner){ if(out instanceof
			 * Interaction){ npair = (Pair<N, N>) insert.c.Ch2PuPair.get(out);
			 * if(npair.first.equals(insert.out)) posOut.add(npair.second); else
			 * posOut.add(npair.first); } else if(out instanceof Gateway){ for(Pair<IRole,
			 * IGateway> pair : insert.c.ChGtw2PuGtws.get(out)){
			 * if((pair.first.toString().equalsIgnoreCase(p.name))){ posOut.add((N)
			 * pair.second); break; } } }else { posOut.add((N) ((PublicModel)
			 * publicModel_p).getEndEvent()); } }
			 * 
			 * //UNCOMMENT //System.out.println("local_in: " + posIn);
			 * //System.out.println("local_out: " + posOut);
			 * 
			 * IFragment<E,N> rf2 = FragmentUtil.complement(f_p, p); RpstModel<E,N>
			 * rf2_model = new RpstModel<E,N>((MultiDirectedGraph<E,N>)rf2.getGraph(),
			 * "fragment"); //System.out.println("rf2: " + rf2_model.getRoot());
			 * changeOps_partner.add(new Insert<E,N>(rf2_model, publicModel_p, posIn,
			 * posOut, insert.c, p)); } //UNCOMMENT
			 * //System.out.println("changeOps_partner= "+changeOps_partner);
			 * changeOps.put(p, changeOps_partner);
			 * 
			 * Set<N> successors = new HashSet<N> (); Set<N> predecessors = new
			 * HashSet<N>(); for(N node : posIn){ publicModel_p.getsuccessorsOfNode(node,
			 * successors); } for(N node : posOut){
			 * publicModel_p.getpredecessorsOfNode(node, predecessors); }
			 * successors.retainAll(predecessors); if(successors.size()==0) //No merge
			 * needed stats.updatePropagationStats(insert.getType(), f_p, Chg_Root_id ==
			 * insert.getId()); else{ //A merge is needed
			 * stats.updatePropagationStats(insert.getType(), f_p, Chg_Root_id ==
			 * insert.getId()); // update with the fragment to insert
			 * stats.updatePropagationStats(insert.getType(), successors, Chg_Root_id ==
			 * insert.getId()); // update with the fragment target to be merged with the
			 * fragment to insert }
			 */
		}
		// System.out.println("change operations:" + changeOps);
		if (Chg_Root_id == insert.getId())
			chgOpId2Stats.put(Chg_Root_id, stats);
		// System.out.println("change operations:" + changeOps);
		return changeOps;
	}

	public static Map<IRole, Map<ChgOpType, Set<IChangeOperation>>> generateChangeOperationsForPublicModel(
			Choreography c, Set<Role> roles) {

		Map<IRole, Map<ChgOpType, Set<IChangeOperation>>> role2ch_op = new HashMap<IRole, Map<ChgOpType, Set<IChangeOperation>>>();

		for (Role role : roles) {
			Map<ChgOpType, Set<IChangeOperation>> type2op = new HashMap<ChgOpType, Set<IChangeOperation>>();
			IPublicModel pum = c.collaboration.R2PuM.get(role);
			type2op.put(ChgOpType.Delete, generateDeleteChangeOperations((PublicModel) pum, c, role));
			type2op.put(ChgOpType.Insert, generateInsertChangeOperations((PublicModel) pum, c, role));
			type2op.put(ChgOpType.Replace, generateReplaceChangeOperations((PublicModel) pum, c, role));
			role2ch_op.put(role, type2op);
		}

		// type2op.put(ChgOpType.Delete, generateDeleteChangeOperations((PublicModel)
		// pm, c,role));

		// type2op.put(ChgOpType.Replace, generateReplaceChangeOperations((PublicModel)
		// pm, c,role))
		return role2ch_op;
	}

	/**
	 * Generates a set of change operation scenarios for a given choreography
	 * 
	 * @param c
	 * @return a Map of the form : Role --> ChgOperationType -->
	 *         SetOfChangeOperations
	 */

	public static Map<IRole, Map<ChgOpType, Set<IChangeOperation>>> generateChangeOperationsForPublicModels(
			Choreography c) {

		Map<IRole, Map<ChgOpType, Set<IChangeOperation>>> role2ch_op = new HashMap<IRole, Map<ChgOpType, Set<IChangeOperation>>>();

		for (IPublicModel pm : c.collaboration.puModels) {
			Map<ChgOpType, Set<IChangeOperation>> type2op = new HashMap<ChgOpType, Set<IChangeOperation>>();
			Role role = c.collaboration.PuM2R.get(pm);
			// type2op.put(ChgOpType.Delete, generateDeleteChangeOperations((PublicModel)
			// pm, c,role));
			// type2op.put(ChgOpType.Insert, generateInsertChangeOperations((PublicModel)
			// pm, c,role));
			type2op.put(ChgOpType.Replace, generateReplaceChangeOperations((PublicModel) pm, c, role));

			role2ch_op.put(role, type2op);
		}
		return role2ch_op;
	}

	/**
	 * Generate a set of Delete change operations for a given RPST Model
	 * 
	 * @param model
	 * @param c
	 * @param role
	 * @return
	 */

	public static <E extends Edge<N>, N extends INode> Set<IChangeOperation> generateDeleteChangeOperations(
			RpstModel<E, N> model, Choreography c, Role role) {

		Set<IChangeOperation> ch_op = new HashSet<IChangeOperation>();
		// generate delete operations
		for (IRPSTNode<E, N> f : model.getRPSTNodes(TCType.BOND)) {
			Delete<E, N> del = new Delete<E, N>(f, model, c, role);
			ch_op.add(del);
		}
		for (IRPSTNode<E, N> f : model.getRPSTNodes(TCType.POLYGON)) {
			Delete<E, N> del = new Delete<E, N>(f, model, c, role);
			ch_op.add(del);
		}
		for (N activity : FragmentUtil.collectActivities(model.getRoot())) {
			Delete<E, N> del = new Delete<E, N>(activity, model, c, role);
			ch_op.add(del);
		}
		// System.out.println("...Number of generated Delete change operations for the
		// role= "+ role+ " "+ ch_op.size());
		return ch_op;
	}

	/**
	 * Generate a set of Insert change operations for a given RPST Model
	 * 
	 * @param model
	 * @param c
	 * @param role
	 * @return
	 */
	public static <E extends Edge<N>, N extends INode> Set<IChangeOperation> generateInsertChangeOperations(
			RpstModel<E, N> model, Choreography c, Role role) {

		Set<IChangeOperation> ch_op = new HashSet<IChangeOperation>();
		// generate Insert operations
		Set<RpstModel<E, N>> allmodels = FragmentUtil.getAllCloneFragmentModels(model);
		for (E edge : model.getdigraph().getEdges()) {
			for (RpstModel<E, N> f : allmodels) {
				Insert<E, N> Ins = new Insert<E, N>(f, model, edge.getSource(), edge.getTarget(), c, role);
				ch_op.add(Ins);
			}
		}
		// System.out.println("...Number of generated Insertion change operations for
		// the role= "+ role+ " "+ ch_op.size());
		return ch_op;
	}

	/**
	 * Generate a set of Replace change operations for a given RPST Model
	 * 
	 * @param model
	 * @param c
	 * @param role
	 * @return
	 */
	public static <E extends Edge<N>, N extends INode> Set<IChangeOperation> generateReplaceChangeOperations(
			RpstModel<E, N> model, Choreography c, Role role) {

		Set<IChangeOperation> ch_op = new HashSet<IChangeOperation>();
		// generate Replace operations
		Set<RpstModel<E, N>> allmodels = FragmentUtil.getAllCloneFragmentModels(model);
		for (IRPSTNode<E, N> f_old : model.getRPSTNodes(TCType.BOND)) {
			for (RpstModel<E, N> f_new : allmodels) {
				Replace<E, N> repl = new Replace<E, N>(f_old, f_new, model, c, role);
				ch_op.add(repl);
			}
		}
		for (IRPSTNode<E, N> f_old : model.getRPSTNodes(TCType.POLYGON)) {
			for (RpstModel<E, N> f_new : allmodels) {
				Replace<E, N> repl = new Replace<E, N>(f_old, f_new, model, c, role);
				ch_op.add(repl);
			}
		}
		// System.out.println("...Number of generated Replace change operations for the
		// role= "+ role+ " "+ ch_op.size());
		return ch_op;
	}
}
